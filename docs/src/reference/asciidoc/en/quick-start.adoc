== Quick Start

WebAuthn is an authentication method that a user registers a public key generated by an authenticator to the server in advance
and the server verifies the signature generated by the authenticator with the public key at the time of authentication.
The data which contains public key and authenticator configuration and is sent at registration is called "attestation", and
the data which contains signature and is sent at authentication is called "assertion".

=== Attestation verification

To verify an attestation on authenticator registration, call `WebAuthnRegistrationContextValidator#validate`.
When invoking, you need to specify an instance of `WebAuthnRegistrationContext` as an argument.

`ClientDataJSON` and `attestationObject`, specified as the argument of the constructor of `WebAuthnRegistrationContext`
are the value obtained by the WebAuthn JS API in the front end side.
`serverProperty` is a parameter that houses values obtained from the server side. Please specify the following valuesâ€‹
when calling the constructor.


- For `origin`, please specify Origin of the site that provides WebAuthn authentication. WebAuthn specification tells that 
the authenticator signs the data including Origin recognized by the browser. WebAuthn4J verifies whether
the written Origin (namely, recognized by the browser) matches the specified Origin in `serverProperty` to prevent 
phishing attacks, which is a behavior required in WebAuthn specification.
- For `rpId`, please set the rpId of the site that provides WebAuthn authentication. rpId is a parameter that specifies
the scope of credentials. For more details, please refer to
https://www.w3.org/TR/webauthn-1/#relying-party-identifier[WebAuthn specification rpId definition].

- For `challenge`, please specify the Challenge issued on WebAuthn JS API call. `challenge` is a parameter to prevent
replay attacks. By issuing the random byte sequence `challenge` on server side, signing it with WebAuthn JS API,
and verifying the signature on server side, users are protected from the replay attack.
It is the application's responsibility for retaining the issued Challenge.
- `tokenBindingId` is a parameter for Token binding. If you do not want to use it please specify `null`.

`userVerificationRequired` is a parameter that indicates whether the user verification on the authenticator is required.

If validation fails, an exception inheriting `ValidationException` is thrown.
If validation succeeds, `WebAuthnRegistrationContextValidationResponse` is returned.
Please create an `Authenticator` instance from the returned value and persist it to the database or something in your
application manner. The instance is required at the time of authentication.

```java
// Client properties
byte[] clientDataJSON = null /* set clientDataJSON */;
byte[] attestationObject = null /* set attestationObject */;

// Server properties
Origin origin = null /* set origin */;
String rpId = null /* set rpId */;
Challenge challenge = null /* set challenge */;
byte[] tokenBindingId = null /* set tokenBindingId */;
ServerProperty serverProperty = new ServerProperty(origin, rpId, challenge, tokenBindingId);
boolean userVerificationRequired = false;

WebAuthnRegistrationContext registrationContext = new WebAuthnRegistrationContext(clientDataJSON, attestationObject, serverProperty, userVerificationRequired);

// WebAuthnRegistrationContextValidator.createNonStrictRegistrationContextValidator() returns a WebAuthnRegistrationContextValidator instance
// which doesn't validate an attestation statement. It is recommended configuration for most web application.
// If you are building enterprise web application and need to validate the attestation statement, use the constructor of
// WebAuthnRegistrationContextValidator and provide validators you like
WebAuthnRegistrationContextValidator webAuthnRegistrationContextValidator =
        WebAuthnRegistrationContextValidator.createNonStrictRegistrationContextValidator();


WebAuthnRegistrationContextValidationResponse response = webAuthnRegistrationContextValidator.validate(registrationContext);

// please persist Authenticator object, which will be used in the authentication process.
Authenticator authenticator =
        new AuthenticatorImpl( // You may create your own Authenticator implementation to save friendly authenticator name
                response.getAttestationObject().getAuthenticatorData().getAttestedCredentialData(),
                response.getAttestationObject().getAttestationStatement(),
                response.getAttestationObject().getAuthenticatorData().getSignCount()
        );
save(authenticator); // please persist authenticator in your manner
```

=== Assertion verification

To verify an assertion on authentication, call `WebAuthnAuthenticationContextValidator#validate`.
```java
// Client properties
byte[] credentialId = null /* set credentialId */;
byte[] clientDataJSON = null /* set clientDataJSON */;
byte[] authenticatorData = null /* set authenticatorData */;
byte[] signature = null /* set signature */;

// Server properties
Origin origin = null /* set origin */;
String rpId = null /* set rpId */;
Challenge challenge = null /* set challenge */;
byte[] tokenBindingId = null /* set tokenBindingId */;
ServerProperty serverProperty = new ServerProperty(origin, rpId, challenge, tokenBindingId);
boolean userVerificationRequired = true;

WebAuthnAuthenticationContext authenticationContext =
        new WebAuthnAuthenticationContext(
                credentialId,
                clientDataJSON,
                authenticatorData,
                signature,
                serverProperty,
                userVerificationRequired
        );
Authenticator authenticator = load(credentialId); // please load authenticator object persisted in the registration process in your manner

WebAuthnAuthenticationContextValidator webAuthnAuthenticationContextValidator =
        new WebAuthnAuthenticationContextValidator();

WebAuthnAuthenticationContextValidationResponse response = webAuthnAuthenticationContextValidator.validate(authenticationContext, authenticator);

// please update the counter of the authenticator record
updateCounter(
        response.getAuthenticatorData().getAttestedCredentialData().getCredentialId(),
        response.getAuthenticatorData().getSignCount()
);
```

