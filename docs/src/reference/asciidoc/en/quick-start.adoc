== Quick Start

WebAuthn is an authentication method that a user registers a public key generated by an authenticator to the server in advance and the server verifies the signature generated by the authenticator with the public key at the time of authentication.

This quickstart will focus on how to validate the WebAuthn "attestation" data, which is sent at registration and contains public key and authenticator configuration, and how to validate the WebAuthn "assertion" data, which is sent at authentication and contains signature.
Apple App Attest attestation and assertion validation is also explained later.

=== WebAuthn verification

==== WebAuthn Attestation verification

To validate an attestation on authenticator registration, call `WebAuthnManager#validate` with a
`RegistrationRequest` instance as an argument.
If you would like to access the parsed data when an validation error occurred, please use `WebAuthnManager#parse` to parse the registration request and pass the returned `RegistrationData` instance to `WebAuthnManager#validate`
method.

The members of `RegistrationRequest` are the values obtained by the WebAuthn JS API in the front end side.
Transmit from the front end side to the server side in some way.

`RegistrationParameters` is an another argument for `WebAuthnManager#parse` method, and contains server property and validation conditions.

`serverProperty` has following members.

- For `origin`, please specify Origin of the site that provides WebAuthn authentication.
WebAuthn specification tells that the authenticator signs the data including Origin recognized by the browser.
WebAuthn4J verifies whether the written Origin (namely, recognized by the browser) matches the specified Origin in `serverProperty` to prevent phishing attacks, which is a behavior required in WebAuthn specification.
- For `rpId`, please set the rpId of the site that provides WebAuthn authentication. rpId is a parameter that specifies the scope of credentials.
For more details, please refer to
https://www.w3.org/TR/webauthn-1/#relying-party-identifier[WebAuthn specification rpId definition].

- For `challenge`, please specify the Challenge issued on WebAuthn JS API call. `challenge` is a parameter to prevent replay attacks.
By issuing the random byte sequence `challenge` on server side, signing it with WebAuthn JS API, and verifying the signature on server side, users are protected from the replay attack.
It is the application's responsibility for retaining the issued Challenge.
- `tokenBindingId` is a parameter for Token binding.
If you do not want to use it please specify `null`.

If validation fails, an exception inheriting `ValidationException` is thrown.
If validation succeeds, please create an `Authenticator` instance from the returned value and persist it to the database or something in your application manner.
The instance is required at the time of authentication.
For more details about `Authenticator` serialization, please refer <<./deep-dive.adoc#authenticator-serialization-and-deserialization,Authenticator serialization and deserialization>>.

[source,java]
----
// Client properties
byte[] attestationObject = null /* set attestationObject */;
byte[] clientDataJSON = null /* set clientDataJSON */;
String clientExtensionJSON = null;  /* set clientExtensionJSON */
Set<String> transports = null /* set transports */;

// Server properties
Origin origin = null /* set origin */;
String rpId = null /* set rpId */;
Challenge challenge = null /* set challenge */;
byte[] tokenBindingId = null /* set tokenBindingId */;
ServerProperty serverProperty = new ServerProperty(origin, rpId, challenge, tokenBindingId);

// expectations
boolean userVerificationRequired = false;
boolean userPresenceRequired = true;

RegistrationRequest registrationRequest = new RegistrationRequest(attestationObject, clientDataJSON, clientExtensionJSON, transports);
RegistrationParameters registrationParameters = new RegistrationParameters(serverProperty, userVerificationRequired, userPresenceRequired);
RegistrationData registrationData;
try {
    registrationData = webAuthnManager.parse(registrationRequest);
} catch (DataConversionException e) {
    // If you would like to handle WebAuthn data structure parse error, please catch DataConversionException
    throw e;
}
try {
    webAuthnManager.validate(registrationData, registrationParameters);
} catch (ValidationException e) {
    // If you would like to handle WebAuthn data validation error, please catch ValidationException
    throw e;
}

// please persist Authenticator object, which will be used in the authentication process.
Authenticator authenticator =
        new AuthenticatorImpl( // You may create your own Authenticator implementation to save friendly authenticator name
                registrationData.getAttestationObject().getAuthenticatorData().getAttestedCredentialData(),
                registrationData.getAttestationObject().getAttestationStatement(),
                registrationData.getAttestationObject().getAuthenticatorData().getSignCount()
        );
save(authenticator); // please persist authenticator in your manner
----

=== WebAuthn Assertion verification

To parse and validate an assertion on authentication, call `WebAuthnManager#validate` with a `AuthenticationRequest`
instance as an argument.
If you would like to access the parsed data when an validation error occurred, please use
`WebAuthnManager#parse` to parse the authentication request and pass the returned `AuthenticationData` instance to `WebAuthnManager#validate` method.

The members of `AuthenticationRequest` are the values obtained by the WebAuthn JS API in the front end side.
Transmit from the front end side to the server side in some way.

AuthenticationParameters is an another argument for WebAuthnManager#parse method, and contains server property, persisted authenticator and validation conditions.

[source,java]
----
// Client properties
byte[] credentialId = null /* set credentialId */;
byte[] userHandle = null /* set userHandle */;
byte[] authenticatorData = null /* set authenticatorData */;
byte[] clientDataJSON = null /* set clientDataJSON */;
String clientExtensionJSON = null /* set clientExtensionJSON */;
byte[] signature = null /* set signature */;

// Server properties
Origin origin = null /* set origin */;
String rpId = null /* set rpId */;
Challenge challenge = null /* set challenge */;
byte[] tokenBindingId = null /* set tokenBindingId */;
ServerProperty serverProperty = new ServerProperty(origin, rpId, challenge, tokenBindingId);

// expectations
List<byte[]> allowCredentials = null;
boolean userVerificationRequired = true;
boolean userPresenceRequired = true;

Authenticator authenticator = load(credentialId); // please load authenticator object persisted in the registration process in your manner

AuthenticationRequest authenticationRequest =
        new AuthenticationRequest(
                credentialId,
                userHandle,
                authenticatorData,
                clientDataJSON,
                clientExtensionJSON,
                signature
        );
AuthenticationParameters authenticationParameters =
        new AuthenticationParameters(
                serverProperty,
                authenticator,
                allowCredentials,
                userVerificationRequired,
                userPresenceRequired
        );

AuthenticationData authenticationData;
try {
    authenticationData = webAuthnManager.parse(authenticationRequest);
} catch (DataConversionException e) {
    // If you would like to handle WebAuthn data structure parse error, please catch DataConversionException
    throw e;
}
try {
    webAuthnManager.validate(authenticationData, authenticationParameters);
} catch (ValidationException e) {
    // If you would like to handle WebAuthn data validation error, please catch ValidationException
    throw e;
}
// please update the counter of the authenticator record
updateCounter(
        authenticationData.getCredentialId(),
        authenticationData.getAuthenticatorData().getSignCount()
);
----

=== Apple App Attest verification

Next, how to verify Apple App Attest is explained.
Since Apple App Attest has a data structure similar to WebAuthn, the validator design follows that of WebAuthn.
Risk metric evaluation is not supported for now.

==== Getting from Maven Central

Apple App Attest validators are contained in the dedicated `webauthn4j-device-check` module.
If you are using maven, add the `webauthn4j-device-check` as a dependency in this way:

[source,xml]
----
<properties>
  ...
  <!-- Use the latest version whenever possible. -->
  <webauthn4j.version>0.13.0.RELEASE</webauthn4j.version>
  ...
</properties>

<dependencies>
  ...
  <dependency>
    <groupId>com.webauthn4j</groupId>
    <artifactId>webauthn4j-device-check</artifactId>
    <version>${webauthn4j.version}</version>
  </dependency>
  ...
</dependencies>
----

==== Apple App Attest attestation verification

To validate an attestation on authenticator registration, call `DeviceCheckManager#validate` with a
`DCAttestationRequest` instance as an argument.
If you would like to access the parsed data when an validation error occurred, please use `DeviceCheckManager#parse` to parse the attestation request and pass the returned `DCAttestationData` instance to `DeviceCheckManager#validate`
method.

The members of `DCAttestationRequest` are the values obtained by the Apple App Attest API in the iOS device Transmit from the iOS device to the server side in some way.

`DCAttestationParameters` is an another argument for `DeviceCheckManager#parse` method, and contains server property and validation conditions.

`DCServerProperty` has following members.

- For `teamIdentifier`, please set the teamIdentifier used for your iOS App development.
For more details, please refer to
https://developer.apple.com/documentation/devicecheck/validating_apps_that_connect_to_your_server[Validating Apps that connect to your server].

- For `cfBundleIdentifier`, please set the cfBundleIdentifier used for your iOS App development.
For more details, please refer to
https://developer.apple.com/documentation/devicecheck/validating_apps_that_connect_to_your_server[Validating Apps that connect to your server].

- For `challenge`, please specify the Challenge issued on App Attest API call. `challenge` is a parameter to prevent replay attacks.
By issuing the random byte sequence `challenge` on server side, signing it with App Attest API, and verifying the signature on server side, users are protected from the replay attack.
It is the application's responsibility for retaining the issued Challenge.

If validation fails, an exception inheriting `ValidationException` is thrown.
If validation succeeds, please create an `DCAppleDevice` instance from the returned value and persist it to the database or something in your application manner.
The instance is required at the time of authentication.

===== Production environment? Development environment?

Apple App Attest can return a development attestation for development.
By default, webAuthn4j-device-check is set to accept a production attestation.
If you want to accept a development attestation, you need to `DCAttestationDataValidator#setProduction` `false`.

[source,java]
----
// Client properties
byte[] keyId = null; /* set keyId */
byte[] attestationObject = null; /* set attestationObject */
byte[] challenge = null; /* set challenge */
byte[] clientDataHash = MessageDigestUtil.createSHA256().digest(challenge);

// Server properties
String teamIdentifier = null /* set teamIdentifier */;
String cfBundleIdentifier = null /* set cfBundleIdentifier */;
DCServerProperty dcServerProperty = new DCServerProperty(teamIdentifier, cfBundleIdentifier, new DefaultChallenge(challenge));

DCAttestationRequest dcAttestationRequest = new DCAttestationRequest(keyId, attestationObject, clientDataHash);
DCAttestationParameters dcAttestationParameters = new DCAttestationParameters(dcServerProperty);
DCAttestationData dcAttestationData;
try {
    dcAttestationData = deviceCheckManager.parse(dcAttestationRequest);
} catch (DataConversionException e) {
    // If you would like to handle Apple App Attest data structure parse error, please catch DataConversionException
    throw e;
}
try {
    deviceCheckManager.validate(dcAttestationData, dcAttestationParameters);
} catch (ValidationException e) {
    // If you would like to handle Apple App Attest data validation error, please catch ValidationException
    throw e;
}

// please persist Authenticator object, which will be used in the authentication process.
DCAppleDevice dcAppleDevice =
        new DCAppleDeviceImpl( // You may create your own Authenticator implementation to save friendly authenticator name
                dcAttestationData.getAttestationObject().getAuthenticatorData().getAttestedCredentialData(),
                dcAttestationData.getAttestationObject().getAttestationStatement(),
                dcAttestationData.getAttestationObject().getAuthenticatorData().getSignCount(),
                dcAttestationData.getAttestationObject().getAuthenticatorData().getExtensions()
        );
save(dcAppleDevice); // please persist authenticator in your manner
----

==== Apple App Attest assertion verification

To parse and validate an assertion on authentication, call `DeviceCheckManager#validate` with a `DCAssertionRequest`
instance as an argument.
If you would like to access the parsed data when an validation error occurred, please use
`DeviceCheckManager#parse` to parse the authentication request and pass the returned `DCAssertionData` instance to `DeviceCheckManager#validate` method.

The members of `DCAssertionRequest` are the values obtained by the App Attest API in the iOS device.
Transmit from the iOS device to the server side in some way.

DCAssertionParameters is an another argument for DeviceCheckManager#parse method, and contains server property, persisted authenticator and validation conditions.

[source,java]
----
// Client properties
byte[] keyId = null /* set keyId */;
byte[] assertion = null /* set assertion */;
byte[] clientDataHash = null /* set clientDataHash */;

// Server properties
String teamIdentifier = null /* set teamIdentifier */;
String cfBundleIdentifier = null /* set cfBundleIdentifier */;
byte[] challenge = null;
DCServerProperty dcServerProperty = new DCServerProperty(teamIdentifier, cfBundleIdentifier, new DefaultChallenge(challenge));

DCAppleDevice dcAppleDevice = load(keyId); // please load authenticator object persisted in the attestation process in your manner

DCAssertionRequest dcAssertionRequest =
        new DCAssertionRequest(
                keyId,
                assertion,
                clientDataHash
        );
DCAssertionParameters dcAssertionParameters =
        new DCAssertionParameters(
                dcServerProperty,
                dcAppleDevice
        );

DCAssertionData dcAssertionData;
try {
    dcAssertionData = deviceCheckManager.parse(dcAssertionRequest);
} catch (DataConversionException e) {
    // If you would like to handle Apple App Attest data structure parse error, please catch DataConversionException
    throw e;
}
try {
    deviceCheckManager.validate(dcAssertionData, dcAssertionParameters);
} catch (ValidationException e) {
    // If you would like to handle Apple App Attest data validation error, please catch ValidationException
    throw e;
}
// please update the counter of the authenticator record
updateCounter(
        dcAssertionData.getCredentialId(),
        dcAssertionData.getAuthenticatorData().getSignCount()
);
----
